package com.mocaris.plugin.flutter.tools.sync

import com.intellij.openapi.actionSystem.*
import com.intellij.openapi.util.io.*
import kotlinx.coroutines.*
import org.yaml.snakeyaml.*
import java.io.*
import kotlin.io.path.*


private val PATTERN = Regex("^[0-9]+(.[0-9]+)?[xX]$")

class AssetsAction : AnAction() {

    private val scope = CoroutineScope(Dispatchers.IO)

    override fun actionPerformed(e: AnActionEvent) {
        scope.launch {
            try {
                val project = e.project
                val projectPath = project?.basePath ?: throw IOException("Not a Flutter Project")
                val pubYamlFile = File(projectPath, "pubspec.yaml")
                if (!pubYamlFile.exists()) {
                    throw IllegalStateException("The 'pubspec.yaml' does not exist. Please make sure this is a Flutter project")
                }
                //读取 yaml 内容
                //image/
                //image/2.0x/
                //image/3.0x/
                val yaml = Yaml()
                val yamlMap = yaml.load<Map<String, Any>>(FileReader(pubYamlFile))
                val toolsNodes =
                    yamlMap["flutter_tools"] as? Map<*, *>?
                        ?: throw NullPointerException("No flutter_tools  node")
                val syncNodes =
                    toolsNodes["assets_sync"] as? Map<*, *>?
                        ?: throw NullPointerException("No assets_sync  node")
                val syncPath =
                    (syncNodes["sync_path"] as? List<*>)?.toSet()
                        ?: throw NullPointerException("No sync_path node")
                val outPath = syncNodes["out_path"] as? String? ?: "lib/generated/r.dart"
                val outClass = syncNodes["out_class"] as? String? ?: "R"
                val pathList = getFilePathList(
                    projectPath,
                    syncPath.map { it.toString() }.toSet()
                )
                writeClass(
                    projectPath,
                    outPath,
                    outClass,
                    pathList
                )
                withContext(Dispatchers.Main) {
                    Utils.showOkDialog(
                        "AssetsSync Success",
                        "Assets Sync Tools Run Successful",
                    )
                }
            } catch (e: Exception) {
                e.printStackTrace()
                withContext(Dispatchers.Main) {
                    Utils.showErrorDialog(
                        "FlutterTools AssetsSync Generate Error",
                        e.message ?: "",
                    )
                }
            }
        }
    }

    @Throws(IOException::class)
    private fun writeClass(
        projectPath: String,
        classPath: String,
        className: String,
        pathList: List<String>
    ) {
        val classFile = File(projectPath, classPath)
        if (!FileUtil.createIfDoesntExist(classFile)) {
            throw IOException("$className can not be created")
        }
        val fileWriter = FileWriter(classFile)
        try {
            fileWriter.appendLine()
            fileWriter.appendLine("// Auto generated by FlutterTools")
            fileWriter.appendLine("// dart format: off")
            fileWriter.appendLine("abstract interface class $className {")
            for (path in pathList) {
                try {
                    if (path.contains(" ")) {
                        fileWriter.appendLine("// TODO The file name '$path' contains empty characters,please check it again");
                    }
                    val classFieldName = path.let {
                        if (it.contains(".")) {
                            it.substringBeforeLast(".")
                        } else it
                    }.replace(Regex("\\W"), "_")
                        .replace(".", "_")
                        .replace(" ", "_")
                        .split("_").toMutableList()
                    val fieldName = classFieldName.mapIndexed { i, it ->
                        if (i != 0) {
                            it.replaceFirstChar { it.uppercase() }
                        } else it
                    }.joinToString("")
                    fileWriter.appendLine("  static const String $fieldName = \"$path\";")
                } catch (e: Exception) {
                    fileWriter.appendLine("// TODO $path generate error,please check it again")
                }
            }
            fileWriter.appendLine("}")
            fileWriter.appendLine("// dart format: on")
            fileWriter.flush()
        } finally {
            fileWriter.close()
        }
    }


    private fun getFilePathList(projectPath: String, list: Set<String>): List<String> {
        val pathList = mutableListOf<String>()
        for (path in list) {
            val fileList = getFileList(projectPath, File(projectPath, path))
            pathList.addAll(fileList)
        }
        return pathList
    }

    //获取 单个 文件或文件夹下的文件
    // isMultiple 是否是倍数率文件夹
    // 返回 相对项目路径文件列表 无文件扩展名
    private fun getFileList(
        projectPath: String,
        file: File,
        isMultiple: Boolean = false
    ): List<String> {
        val list = mutableSetOf<String>()
        val rootPath = Path(projectPath)
        if (file.isDirectory) {
            val listFiles = file.listFiles() ?: return emptyList()
            // 当前文件夹是否是倍数率文件夹
            val isMultiple = file.nameWithoutExtension.matches(PATTERN)
            for (subFile in listFiles) {
                val mutFileList = getFileList(projectPath, subFile, isMultiple)
                list.addAll(mutFileList)
            }
        } else {
            val finalFile: File = if (isMultiple) {
                File(file.parentFile.parent, file.name)
            } else file
            // file path 转为 linux path
            list.add(toLinuxPath(rootPath.relativize(finalFile.toPath()).toString()))
        }
        return list.sortedBy { it.lowercase() }
    }

    private fun toLinuxPath(path: String): String {
        // 将 windows path 转为 linux path
        if (File.separator != "/") {
            return path.replace(File.separator, "/")
        }
        return path
    }
}



