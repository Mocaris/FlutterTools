package com.mocaris.plugin.flutter.tools.sync

import com.intellij.openapi.util.io.*
import com.intellij.openapi.vfs.LocalFileSystem
import com.mocaris.plugin.flutter.tools.model.*
import kotlinx.coroutines.*
import org.yaml.snakeyaml.*
import java.io.*
import kotlin.io.path.*

const val PUBSPEC_FILE_NAME = "pubspec.yaml"
const val TOOLS_FILE_NAME = "flutter_tools.yaml"

private val MUT_PATTERN = Regex("^[0-9]+(.[0-9]+)?[xX]$")

private const val DEFAULT_OUT_PATH = "lib/r.dart"
private const val DEFAULT_OUT_CLASS = "R"

object AssetsClassGenHelper {

    @Throws(Exception::class)
    fun parseYaml(toolsYamlFile: File, pubYamlFile: File): AssetsSyncConfig {
        return try {
            loadYamlConfig(toolsYamlFile)
        } catch (e: Exception) {
            loadYamlConfig(pubYamlFile)
        }
    }

    private fun loadYamlConfig(yamlFile: File): AssetsSyncConfig {
        val yaml = Yaml()
        val yamlMap = yaml.load<Map<String, Any>>(FileReader(yamlFile))
        val toolsNodes =
            yamlMap["flutter_tools"] as? Map<*, *>?
                ?: throw NullPointerException("No flutter_tools  node")
        val syncNodes =
            toolsNodes["assets_sync"] as? Map<*, *>?
                ?: throw NullPointerException("No assets_sync  node")
        val syncPath =
            (syncNodes["sync_path"] as? List<*>?)?.map { it.toString() }?.toSet()
                ?: throw NullPointerException("No sync_path node")
        val outPath = syncNodes["out_path"] as? String? ?: DEFAULT_OUT_PATH
        val outClass = syncNodes["out_class"] as? String? ?: DEFAULT_OUT_CLASS
        val watch = syncNodes["watch"] as? Boolean? ?: false
        return AssetsSyncConfig(
            sync_path = syncPath,
            out_path = outPath,
            out_class = outClass,
            watcher = watch
        )
    }

    @Throws(Exception::class)
    suspend fun startSyncGen(
        projectPath: String,
        syncConfig: AssetsSyncConfig
    ) = withContext(Dispatchers.IO) {
        val pathList = getFilePathList(
            projectPath,
            syncConfig.sync_path.toSet()
        )
        writeClass(
            projectPath,
            syncConfig.out_path,
            syncConfig.out_class,
            pathList
        )
    }


    @Throws(IOException::class)
    private fun writeClass(
        projectPath: String,
        classPath: String,
        className: String,
        nodeList: List<AssetsNode>
    ) {
        val project = File(projectPath)
        val classFile = File(project, toSystemPath(classPath))
        if (!FileUtil.createIfDoesntExist(classFile)) {
            throw IOException("$className can not be created")
        }
        val projectName = project.name
        val fileWriter = FileWriter(classFile)
        try {
            fileWriter.appendLine()
            fileWriter.appendLine("// Auto generated by FlutterTools")
            fileWriter.appendLine("// dart format: off")
            fileWriter.appendLine("abstract interface class $className {")
            for (node in nodeList) {
                try {
                    if (node.name.contains(" ")) {
                        fileWriter.appendLine("// TODO The file name '${node.path}' contains empty characters,please check it again");
                    }
                    val fieldName = pathConvertFieldName(projectName, node)
                    fileWriter.appendLine("  static const String $fieldName = \"${node.path}\";")
                } catch (e: Exception) {
                    fileWriter.appendLine("// TODO ${node.path} generate error,please check it again")
                }
            }
            fileWriter.appendLine("}")
            fileWriter.appendLine("// dart format: on")
            fileWriter.flush()
        } finally {
            fileWriter.close()
        }
        LocalFileSystem.getInstance().refreshAndFindFileByIoFile(classFile)
    }

    private fun pathConvertFieldName(projectName: String, node: AssetsNode): String {
        val nodePath = node.parentPath
        val pathName =
            "${nodePath.ifEmpty { projectName }}/${node.name}"
                .replace(Regex("\\W"), "_")
                .removePrefix("_")
                .removeSuffix("_")
                .split("_")
                .toMutableList()
        var fieldName = pathName.mapIndexed { i, it ->
            (if (i != 0) {
                it.replaceFirstChar { it.uppercase() }
            } else it).ifEmpty { "_" }
        }.joinToString("")
        if (node.extension.isNotEmpty()) {
            fieldName += "_${node.extension}"
        }
        return fieldName
    }

    private fun getFilePathList(projectPath: String, list: Set<String>): List<AssetsNode> {
        val pathList = mutableSetOf<AssetsNode>()
        for (path in list) {
            val syncFile = File(projectPath, toSystemPath(path))
            val isMultiple = syncFile.name.matches(MUT_PATTERN)
            val fileList = getFileList(projectPath, syncFile, isMultiple)
            pathList.addAll(fileList)
        }
        return pathList.sortedBy { it.parentPath.lowercase() }
    }

    //获取 单个 文件或文件夹下的文件
    // isMultiple 是否是倍数率文件夹
    // 返回 相对项目路径文件列表 无文件扩展名
    private fun getFileList(
        projectPath: String,
        file: File,
        isMultiple: Boolean = false
    ): Set<AssetsNode> {
        if (!file.exists()) {
            return emptySet()
        }
        val list = mutableSetOf<AssetsNode>()
        val rootPath = Path(projectPath)
        if (file.isDirectory) {
            val listFiles = file.listFiles() ?: return emptySet()
            // 当前文件夹是否是倍数率文件夹
            val isMultiple = file.name.matches(MUT_PATTERN)
            for (subFile in listFiles) {
                val mutFileList = getFileList(projectPath, subFile, isMultiple)
                list.addAll(mutFileList)
            }
        } else {
            val finalFile: File = if (isMultiple) {
                File(file.parentFile.parent, file.name)
            } else file
            // file path 转为 linux path

            list.add(
                AssetsNode(
                    name = file.nameWithoutExtension,
                    extension = file.extension,
                    parentPath = toLinuxPath(
                        rootPath.relativize(finalFile.parentFile.toPath()).toString()
                    ),
                    path = toLinuxPath(
                        rootPath.relativize(finalFile.toPath()).toString()
                    )
                )
            )
        }
        return list
    }

    private fun toLinuxPath(path: String): String {
        // 将 windows path 转为 linux path
        if (File.separator != "/") {
            return path.replace(File.separator, "/")
        }
        return path
    }

    private fun toSystemPath(path: String): String {
        if (File.separator != "/") {
            return path.replace("/", File.separator)
        }
        return path
    }
}