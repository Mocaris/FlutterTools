package com.mocaris.plugin.flutter.tools.sync

import com.intellij.openapi.util.io.FileUtil
import com.mocaris.plugin.flutter.tools.model.AssetsSyncConfig
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.yaml.snakeyaml.Yaml
import java.io.File
import java.io.FileReader
import java.io.FileWriter
import java.io.IOException
import kotlin.io.path.Path

private val MUT_PATTERN = Regex("^[0-9]+(.[0-9]+)?[xX]$")

object AssetsClassGenHelper {

    @Throws(Exception::class)
    fun parseYaml(pubYamlFile: File): AssetsSyncConfig {
        val yaml = Yaml()
        val yamlMap = yaml.load<Map<String, Any>>(FileReader(pubYamlFile))
        val toolsNodes =
            yamlMap["flutter_tools"] as? Map<*, *>?
                ?: throw NullPointerException("No flutter_tools  node")
        val syncNodes =
            toolsNodes["assets_sync"] as? Map<*, *>?
                ?: throw NullPointerException("No assets_sync  node")
        val syncPath =
            (syncNodes["sync_path"] as? List<*>?)?.map { it.toString() }
                ?: throw NullPointerException("No sync_path node")
        val outPath = syncNodes["out_path"] as? String? ?: "lib/generated/r.dart"
        val outClass = syncNodes["out_class"] as? String? ?: "R"
        return AssetsSyncConfig(
            sync_path = syncPath,
            out_path = outPath,
            out_class = outClass
        )
    }

    @Throws(Exception::class)
    suspend fun startSyncGen(
        projectPath: String,
        syncConfig: AssetsSyncConfig
    ) = withContext(Dispatchers.IO) {
        val pathList = getFilePathList(
            projectPath,
            syncConfig.sync_path.toSet()
        )
        writeClass(
            projectPath,
            syncConfig.out_path,
            syncConfig.out_class,
            pathList
        )
    }


    @Throws(IOException::class)
    private fun writeClass(
        projectPath: String,
        classPath: String,
        className: String,
        pathList: List<String>
    ) {
        val classFile = File(projectPath, classPath)
        if (!FileUtil.createIfDoesntExist(classFile)) {
            throw IOException("$className can not be created")
        }
        val fileWriter = FileWriter(classFile)
        try {
            fileWriter.appendLine()
            fileWriter.appendLine("// Auto generated by FlutterTools")
            fileWriter.appendLine("// dart format: off")
            fileWriter.appendLine("abstract interface class $className {")
            for (path in pathList) {
                try {
                    if (path.contains(" ")) {
                        fileWriter.appendLine("// TODO The file name '$path' contains empty characters,please check it again");
                    }
                    val classFieldName = path.let {
                        if (it.contains(".")) {
                            it.substringBeforeLast(".")
                        } else it
                    }.replace(Regex("\\W"), "_")
                        .replace(".", "_")
                        .replace(" ", "_")
                        .split("_").toMutableList()
                    val fieldName = classFieldName.mapIndexed { i, it ->
                        if (i != 0) {
                            it.replaceFirstChar { it.uppercase() }
                        } else it
                    }.joinToString("")
                    fileWriter.appendLine("  static const String $fieldName = \"$path\";")
                } catch (e: Exception) {
                    fileWriter.appendLine("// TODO $path generate error,please check it again")
                }
            }
            fileWriter.appendLine("}")
            fileWriter.appendLine("// dart format: on")
            fileWriter.flush()
        } finally {
            fileWriter.close()
        }
    }


    private fun getFilePathList(projectPath: String, list: Set<String>): List<String> {
        val pathList = mutableListOf<String>()
        for (path in list) {
            val fileList = getFileList(projectPath, File(projectPath, path))
            pathList.addAll(fileList)
        }
        return pathList
    }

    //获取 单个 文件或文件夹下的文件
    // isMultiple 是否是倍数率文件夹
    // 返回 相对项目路径文件列表 无文件扩展名
    private fun getFileList(
        projectPath: String,
        file: File,
        isMultiple: Boolean = false
    ): List<String> {
        val list = mutableSetOf<String>()
        val rootPath = Path(projectPath)
        if (file.isDirectory) {
            val listFiles = file.listFiles() ?: return emptyList()
            // 当前文件夹是否是倍数率文件夹
            val isMultiple = file.nameWithoutExtension.matches(MUT_PATTERN)
            for (subFile in listFiles) {
                val mutFileList = getFileList(projectPath, subFile, isMultiple)
                list.addAll(mutFileList)
            }
        } else {
            val finalFile: File = if (isMultiple) {
                File(file.parentFile.parent, file.name)
            } else file
            // file path 转为 linux path
            list.add(toLinuxPath(rootPath.relativize(finalFile.toPath()).toString()))
        }
        return list.sortedBy { it.lowercase() }
    }

    private fun toLinuxPath(path: String): String {
        // 将 windows path 转为 linux path
        if (File.separator != "/") {
            return path.replace(File.separator, "/")
        }
        return path
    }
}