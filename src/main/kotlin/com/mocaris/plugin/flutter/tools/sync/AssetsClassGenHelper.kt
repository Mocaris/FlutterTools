package com.mocaris.plugin.flutter.tools.sync

import com.intellij.openapi.util.io.*
import com.intellij.openapi.vfs.*
import com.mocaris.plugin.flutter.tools.model.*
import kotlinx.coroutines.*
import org.yaml.snakeyaml.*
import java.io.*
import kotlin.io.path.*

object AssetsClassGenHelper {

    @Throws(Exception::class)
    fun parseYaml(toolsYamlFile: File, pubYamlFile: File): AssetsSyncConfig {
        return try {
            loadYamlConfig(toolsYamlFile)
        } catch (e: Exception) {
            loadYamlConfig(pubYamlFile)
        }
    }

    private fun loadYamlConfig(yamlFile: File): AssetsSyncConfig {
        val yaml = Yaml()
        val yamlMap = yaml.load<Map<String, Any>>(FileReader(yamlFile))
        val toolsNodes =
            yamlMap["flutter_tools"] as? Map<*, *>?
                ?: throw NullPointerException("No flutter_tools  node")
        val syncNodes =
            toolsNodes["assets_sync"] as? Map<*, *>?
                ?: throw NullPointerException("No assets_sync  node")
        val syncPath =
            (syncNodes["sync_path"] as? List<*>?)?.map { it.toString() }?.toSet()
                ?: throw NullPointerException("No sync_path node")
        val outPath = syncNodes["out_path"] as? String? ?: DEFAULT_OUT_PATH
        val outClass = syncNodes["out_class"] as? String? ?: DEFAULT_OUT_CLASS
        val excluded = (syncNodes["excluded"] as? List<*>?)?.map { it.toString() }?.toSet()
            ?: DEFAULT_EXCLUDE
        val watch = syncNodes["watch"] as? Boolean? ?: false
        val outExtension = syncNodes["out_extension"] as? Boolean? ?: false
        return AssetsSyncConfig(
            syncPath = syncPath,
            outPath = outPath,
            outClass = outClass,
            watcher = watch,
            outExtension = outExtension,
            excluded = excluded
        )
    }

    @Throws(Exception::class)
    suspend fun startSyncGen(
        projectPath: String,
        syncConfig: AssetsSyncConfig
    ) = withContext(Dispatchers.IO) {
        val pathList = getFilePathList(
            projectPath,
            syncConfig.syncPath.toSet(),
            syncConfig.excluded,
        )
        writeClass(
            projectPath,
            syncConfig.outPath,
            syncConfig.outClass,
            pathList,
            syncConfig.outExtension,
        )
    }


    @Throws(IOException::class)
    private fun writeClass(
        projectPath: String,
        classPath: String,
        className: String,
        nodeList: List<AssetsNode>,
        outExtension: Boolean,
    ) {
        val project = File(projectPath)
        val classFile = File(project, toSystemPath(classPath))
        if (!FileUtil.createIfDoesntExist(classFile)) {
            throw IOException("$className can not be created")
        }
        val projectName = project.name
        val fileWriter = FileWriter(classFile)
        try {
            fileWriter.appendLine()
            fileWriter.appendLine("// Auto generated by FlutterTools")
            fileWriter.appendLine("// dart format: off")
            fileWriter.appendLine("abstract interface class $className {")
            for (node in nodeList) {
                try {
                    if (node.name.contains(" ")) {
                        fileWriter.appendLine("// TODO The file name '${node.path}' contains empty characters,please check it again");
                    }
                    val fieldName = pathConvertFieldName(projectName, node, outExtension)
                    fileWriter.appendLine("  static const String $fieldName = \"${node.path}\";")
                } catch (e: Exception) {
                    fileWriter.appendLine("// TODO ${node.path} generate error,please check it again")
                }
            }
            fileWriter.appendLine("}")
            fileWriter.appendLine("// dart format: on")
            fileWriter.flush()
        } finally {
            fileWriter.close()
        }
        LocalFileSystem.getInstance().refreshAndFindFileByIoFile(classFile)
    }

    private fun pathConvertFieldName(
        projectName: String,
        node: AssetsNode,
        outExtension: Boolean
    ): String {
        val nodePath = node.parentPath
        val fileName = node.name
        val nameIsEmpty = fileName.isEmpty()
        val pathName =
            "${nodePath.ifEmpty { projectName }}/$fileName"
                .replace(Regex("\\W"), "_")
                .removePrefix("_")
                .removeSuffix("_")
                .split("_")
                .toMutableList()
        var fieldName = pathName.mapIndexed { i, it ->
            if (i != 0) {
                it.replaceFirstChar { it.uppercase() }
            } else it
        }.joinToString("")
        if (nameIsEmpty) {
            fieldName += "_"
        }
        if (nameIsEmpty || outExtension) {
            fieldName += node.extension.replaceFirstChar { it.uppercase() }
        }
        return fieldName
    }

    private fun getFilePathList(
        projectPath: String,
        list: Set<String>,
        excluded: Set<String>
    ): List<AssetsNode> {
        val pathList = mutableSetOf<AssetsNode>()
        for (path in list) {
            val syncFile = File(projectPath, toSystemPath(path))
            val isMultiple = syncFile.name.matches(MUT_PATTERN)
            val fileList = getFileList(projectPath, syncFile, isMultiple)
            pathList.addAll(fileList)
        }
        val regexes = excluded.map { patternToRegex(it) }

        pathList.removeAll { shouldExclude(it, regexes) }
        return pathList.sortedBy { it.parentPath.lowercase() }
    }

    //排除 匹配规则
    // 1. 匹配全部字符串
    // 2. 匹配 *.filename
    // 3. 匹配 filename.*
    // 4. 匹配 assets/path/*
    // 5. 匹配 assets/path/
    // 6. 匹配 assets/path
    private fun shouldExclude(node: AssetsNode, patterns: List<Regex>): Boolean {
        val path = node.path
        return patterns.any {
            it.matches(path)
        }
    }

    private fun patternToRegex(pattern: String): Regex {
        return when {
            // start with *
            pattern.startsWith("*") -> {
                val ext = Regex.escape(pattern.removePrefix("*"))
                Regex("^(.+)?$ext$")
            }

            // end with *
            pattern.endsWith("*") -> {
                val prefix = Regex.escape(pattern.removeSuffix("*"))
                Regex("^${prefix}(.+)?$")
            }

            pattern.contains("*") -> {
                val prefix = Regex.escape(pattern.replace("*", ".+"))
                Regex("^${prefix}$")
            }
            // end with /  or end with /*
            // path/path/ or path/path/*
            pattern.endsWith("/") || pattern.endsWith("/*") -> {
                val prefix = Regex.escape(pattern.removeSuffix("*").removeSuffix("/"))
                Regex("^${prefix}(.+)?$")
            }

            !pattern.contains(".") -> {
                Regex("^${Regex.escape(pattern)}(.+)?$")
            }

            pattern.startsWith(".") -> {
                Regex("^(.+)?${Regex.escape(pattern)}$")
            }

            // 完整路径
            else -> Regex("^${Regex.escape(pattern)}$")
        }
    }

    //获取 单个 文件或文件夹下的文件
    // isMultiple 是否是倍数率文件夹
    // 返回 相对项目路径文件列表 无文件扩展名
    private fun getFileList(
        projectPath: String,
        file: File,
        isMultiple: Boolean = false
    ): Set<AssetsNode> {
        if (!file.exists()) {
            return emptySet()
        }
        val list = mutableSetOf<AssetsNode>()
        val rootPath = Path(projectPath)
        if (file.isDirectory) {
            val listFiles = file.listFiles() ?: return emptySet()
            // 当前文件夹是否是倍数率文件夹
            val isMultiple = file.name.matches(MUT_PATTERN)
            for (subFile in listFiles) {
                val mutFileList = getFileList(projectPath, subFile, isMultiple)
                list.addAll(mutFileList)
            }
        } else {
            val finalFile: File = if (isMultiple) {
                File(file.parentFile.parent, file.name)
            } else file
            // file path 转为 linux path

            list.add(
                AssetsNode(
                    name = file.nameWithoutExtension,
                    extension = file.extension,
                    parentPath = toLinuxPath(
                        rootPath.relativize(finalFile.parentFile.toPath()).toString()
                    ),
                    path = toLinuxPath(
                        rootPath.relativize(finalFile.toPath()).toString()
                    )
                )
            )
        }
        return list
    }

    private fun toLinuxPath(path: String): String {
        // 将 windows path 转为 linux path
        if (File.separator != "/") {
            return path.replace(File.separator, "/")
        }
        return path
    }

    private fun toSystemPath(path: String): String {
        if (File.separator != "/") {
            return path.replace("/", File.separator)
        }
        return path
    }
}